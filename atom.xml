<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[台伟的博客]]></title>
  <subtitle><![CDATA[WatchOS,iOS WatchKit开发]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://"/>
  <updated>2015-07-08T01:15:17.692Z</updated>
  <id>http://</id>
  
  <author>
    <name><![CDATA[台伟]]></name>
    <email><![CDATA[taiw@163.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[WatchConnectivity通信框架小结]]></title>
    <link href="http:/2015/07/07/WatchConnectivity%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6%E5%B0%8F%E7%BB%93/"/>
    <id>http:/2015/07/07/WatchConnectivity通信框架小结/</id>
    <published>2015-07-07T01:12:56.000Z</published>
    <updated>2015-07-08T01:15:17.692Z</updated>
    <content type="html"><![CDATA[<p>WatchConnectivity是watchOS2里iPhone与AppleWatch通信的基础框架，作为开发AppleWatch应用的必学内容，我在学习后进行了小小的归纳总结。</p>
<h1 id="初始化设置">初始化设置</h1><p>WatchConnectivity的原理是iPhone伴侣应用和AppleWatch上运行的WatchKit Extension之间通过WCSession会话进行通信。<br>当前Controller若需要响应WatchConnectivity的消息需要遵循WCSessionDelegate协议。<br>初始化时需要激活会话代理（iPhone应用和WatchKitExtension里都要激活），代码如下：<br>if WCSession.isSupported() {<br> let session=WCSession.defaultSession()<br> session.delegate=self<br> session.activateSession()<br>}</p>
<h1 id="会话状态">会话状态</h1><p>为了了解iPhone应用与Watch应用的会话状态，我们可以通过一些属性去判断，注意这些操作只能在iPhone应用里进行。</p>
<h2 id="1-检查是否配对">1.检查是否配对</h2><p>AppleWatch是否与iPhone配对，可以通过session.paired属性的布尔值进行判断</p>
<h2 id="2-检查watchapp是否已安装">2.检查watchapp是否已安装</h2><p>即使已配对，watchapp也可能未安装成功，通过session.watchAppInstalled属性的布尔值可以得知此状态。另外，watchapp安装成功就会在手表上建立相应app的目录，因此session.watchAppInstalled==false效果等同于watchDirectoryURL != nil。<br>watchDirectoryURL一般只在需要额外的初始化处理的情况下，比如app重装恢复队列内容、设定初始设置时等情况下会用到。</p>
<h2 id="3-检查是否开启表盘组件功能">3.检查是否开启表盘组件功能</h2><p>若watchapp支持complication表盘组件，那么session.complicationEnabled值为true。</p>
<h1 id="通信">通信</h1><p>WatchConnectivity框架的通信方式有两种模式，一种是后台传输，另一种是交互式消息。</p>
<h2 id="后台传输模式">后台传输模式</h2><p>后台传输模式是最常用的通信模式，面向内容与用户交互，主要用于传输非即时的内容，体现在内容可由操作系统智能传输（操作系统允许发送方可退出，选择传输时机，支持接收者下次启动时发送），并将内容以队列方式发送。<br>后台传输一般分三种类型：<br><strong>1. Application context</strong><br>发送方代码示例<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">let</span> context=<span class="comment">//最新内容,初始化context</span></span><br><span class="line"><span class="keyword">try</span> WCSession.defaultSession().updateApplicationContext(context)</span><br><span class="line">&#125;<span class="keyword">catch</span> &#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接收方需响应以下代理方法，<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">session</span><span class="params">(session:WCSession,didReceiveApplicationContext:applicationContext:[String:AnyObject])</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ApplicationContext传输数据常见于传输单个字典类型数据的情况，非常适合仅需要信息子集的AppleWatch应用。</p>
<p><strong>2. Userinfo transfer</strong><br>Userinfo方式与ApplicationContext相比能够传输更复杂的数据。<br>发送方示例代码：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let userInfo=<span class="comment">//待传输的内容</span></span><br><span class="line">let userInfoTransfer=WCSession.<span class="function"><span class="title">defaultSession</span><span class="params">()</span></span>.<span class="function"><span class="title">transferUserInfo</span><span class="params">(userInfo)</span></span></span><br></pre></td></tr></table></figure></p>
<p>userInfoTransfer传输器封装了待传数据，并且你可以通过代码控制来取消传输。<br>未传输的内容可以这样获取<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let transfer=WCSession.<span class="function"><span class="title">defaultSession</span><span class="params">()</span></span>.<span class="function"><span class="title">outstandingUserInfoTransfer</span><span class="params">(userInfo)</span></span></span><br></pre></td></tr></table></figure></p>
<p>接收方通过以下回调方法进行处理：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">session</span><span class="params">(session:WCSession,didReceiveUserInfo userInfo:[String:AnyObject])</span></span> &#123;</span><br><span class="line"><span class="comment">//处理接收的userInfo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Userinfo transfer适合内存内容的传输，并且支持访问队列里的未传输内容。<br><strong>3. File transfer</strong><br>File transfer面向文件，API使用上和Userinfo transfer很像，支持队列，支持未完成内容的访问，需要附加元数据信息。<br>发送方示例代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let url=<span class="comment">//文件地址</span></span><br><span class="line">let metadata=<span class="comment">//字典形式元数据</span></span><br><span class="line">let fileTransfer=WCSession.<span class="function"><span class="title">defaultSession</span><span class="params">()</span></span>.<span class="function"><span class="title">transferFile</span><span class="params">(url,metadata:metadata)</span></span></span><br></pre></td></tr></table></figure></p>
<p>接收方代码如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">session</span><span class="params">(session:WCSession,didReceiveFile file:WCSessionFile)</span></span> &#123;</span><br><span class="line"><span class="comment">//处理接收的File</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="交互式消息">交互式消息</h2><p>交互式消息能够为iPhone和AppleWatch间提供实时的通讯功能。<br>使用前提：1.设备间能够无线联通；2.应用之间能够联通，这意味着AppleWatch端的程序必须前台运行，即session的reachable值为true。<br>与后台传输模式的一个值得注意的区别是：若iOS应用未启动，AppleWatch上运行的WatchKit扩展能够启动iOS应用！<br>交互式消息方式可以传输两种数据类型的消息：<br><strong>1.字典</strong><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">sendMessage</span><span class="params">(message:,replyHandler:,errorHandler:)</span></span></span><br></pre></td></tr></table></figure></p>
<p><strong>2.数据</strong><br>支持可序列化的自定义数据<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">sendMessageData</span><span class="params">(data:,replyHandler:,errorHandler:)</span></span></span><br></pre></td></tr></table></figure></p>
<p>值得注意的是，replyHandler是optional可选类型，但目前版本里(Xcode7beta2)若使用nil作为参数，系统将无法确认而认为发送消息失败。<br>在以下方法里进行接收时的回调处理<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">session</span><span class="params">(session:WCSession,didReceiveMessage message:[String:AnyObject],replyHandler:<span class="params">([String:AnyObject])</span></span></span> -&gt; <span class="type">Void</span>)&#123;</span><br><span class="line"><span class="comment">//消息处理并返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>WatchConnectivity是watchOS2里iPhone与AppleWatch通信的基础框架，作为开发AppleWatch应用的必学内容，我在学习后进行了小小的归纳总结。</p>
<h1 id="初始化设置">初始化设置</h1><p>WatchConnectiv]]>
    </summary>
    
      <category term="iOS" scheme="http:/tags/iOS/"/>
    
      <category term="swift" scheme="http:/tags/swift/"/>
    
      <category term="watchOS" scheme="http:/tags/watchOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[AppleWatch应用优化的一些心得技巧总结]]></title>
    <link href="http:/2015/05/29/AppleWatch%E5%BA%94%E7%94%A8%E4%BC%98%E5%8C%96%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"/>
    <id>http:/2015/05/29/AppleWatch应用优化的一些心得技巧总结/</id>
    <published>2015-05-29T10:56:59.000Z</published>
    <updated>2015-07-08T01:16:43.311Z</updated>
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;在笔者3月份为AppleWatch开发RebelSheep小游戏进行真机测试的时候就发现了目前AppleWatch上第三方应用的性能并不理想，而测试部分WatchAppStore里推荐的应用甚至都没能成功开启。尽管WatchOS 1.01已经提升了已优化了应用启动的速度，但用户普遍感受还是体验较差，因此我们有必要尽全力优化自己的AppleWatch应用。笔者结合自己的体会和其它先驱者的一些心得对相关技巧做了一些汇总，分设计优化和资源优化两方面来说一下。</p>
<blockquote>
<p><strong>优化目标</strong>：缩短WatchApp的启动时间，提升响应速度<br><strong>代码环境</strong>：Swift 1.2、Xcode6.3.2</p>
</blockquote>
<h2 id="1_程序设计优化">1 程序设计优化</h2><p>&nbsp;&nbsp;与iPhone应用可以充分发挥艺术品质的设计所不同，AppleWatch应用必须遵循简单、直接、轻量级的原则，因此在整个软件界面及程序架构模型设计上就必须全面考虑。Apple官方文档《<a href="https://developer.apple.com/watchkit/tips/" target="_blank" rel="external">WatchKit Development Tips</a>》里提到，为了提升性能，AppleWatch应用应实现：最少的通信量、只更新变化的内容、延迟加载内容、快速初始化分页控制器、简化控制器场景、减少表格初始显示行数。下面我们具体看一下：<br><strong>1.1 最少的通信量&amp;只更新变化内容</strong><br>&nbsp;&nbsp;WatchKit扩展应用开发目前面临的一个很大麻烦就是UI组件的状态都是可写而不可读的，这样每次刷新界面内容时很难判断哪些是变动的数据而不得不把屏幕上所有内容都更新一遍。RobinSenior在<a href="http://techblog.thescore.com/2015/05/20/reducing-watchkit-traffic-with-view-models/" target="_blank" rel="external">这篇</a>文章里提出利用视图模型的存储可以减少通信量和实现仅更新变化对象的数据。其实道理很简单，就是实现一个协议，判断原始内容是否和新内容一致。<br>&nbsp;&nbsp;比如对于标签控件WKInterfaceLabel，利用以下代码可以实现仅当标签文本发生变化时才更新标签内容。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Updatable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">T</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">updateFrom</span><span class="params">(oldValue : T?, to newValue : T?)</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">WKInterfaceLabel</span> : <span class="title">Updatable</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">updateFrom</span><span class="params">(oldValue:String?, to newValue:String?)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> newValue != oldValue &#123;</span><br><span class="line">            <span class="keyword">self</span>.setText(newValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;对于WKInterfaceImage，可利用此思路实现图像下载的网络地址改变时才去下载缓存图像并更新图片，对于WKInterfaceTable可以实现读取表格后续数据行直接在表格后附加而不用刷新整个表格等等，这里不多赘述。</p>
<p><strong>1.2 内容延迟加载</strong><br>&nbsp;&nbsp;为了优化WatchApp的启动速度和响应能力，我们的程序设计上需要考虑初始化时只加载本屏显示的内容，滚屏显示的额外内容延迟加载。而使用dispatch_async异步方式去处理耗时长的界面图像元素加载等任务将能够更快的提前呈现视图控制器。大致代码结构如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">willActivate</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">super</span>.willActivate()</span><br><span class="line">      dispatch_async(dispatch_get_main_queue(), &#123;</span><br><span class="line">          <span class="comment">//加载界面的图像元素等长时间操作</span></span><br><span class="line">      &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;顺便一提，利用Swift语言的lazy关键字修饰变量，其懒加载机制也可降低初始化工作的压力。    </p>
<p><strong>1.3 快速初始化分页控制器</strong><br>&nbsp;&nbsp;在使用多页视图模式时一定要特别注意，各页的控制器的init和awakeWithContext会比第一页控制器的willActivate更早执行，因此每页的数据加载等长时间任务有必要放到willActivate函数里运行。另外，每次切换分页都会执行对应控制器的willActivate函数，而在Watch OS 1.01版里，为了提升性能系统甚至会提前运行下一页的willActivate，为了少做无用功，我们可以设计一些缓存和避免重复加载的功能。</p>
<p> <strong>1.4 简化控制器场景、减少表格初始行数</strong><br>&nbsp;&nbsp;我们为了实现一些提示功能，可能会在控制器里放置一些隐藏的标签控件等，但如果数量太多，也会严重影响视图加载速度。而对于表格，前面已经提到，最初应该仅加载第一屏里能看到的行。这些措施都能够大幅提升响应速度。</p>
<p><strong>1.5 其它补充</strong><br> <em>1.5.1 状态保存</em><br>&nbsp;&nbsp;Apple官方文档《<a href="https://developer.apple.com/watchkit/tips/" target="_blank" rel="external">WatchKit Development Tips</a>》里建议，我们可以在视图控制器的willActivate和didDeactivate两个方法里恢复/保存app的状态和数据。但很多情况下是不必要的（比如在多视图场景切换时也会执行有关代码），一项更好的选择是利用以下系统通知：<br>?NSExtensionHostWillEnterForegroundNotification<br>?NSExtensionHostDidBecomeActiveNotification<br>?NSExtensionHostWillResignActiveNotification<br>?NSExtensionHostDidEnterBackgroundNotification<br>&nbsp;&nbsp;我们可以在主视图控制器的init或awakeWithContext里通过NSNotificationCenter注册，比如:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line"> <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        </span><br><span class="line"> <span class="type">NSNotificationCenter</span>.defaultCenter().addObserver(</span><br><span class="line">	<span class="keyword">self</span>, selector:<span class="string">"onDeactivate"</span>, name:<span class="string">"NSExtensionHostWillResignActiveNotification"</span>, object: <span class="literal">nil</span>)</span><br><span class="line"> </span><br><span class="line"> <span class="type">NSNotificationCenter</span>.defaultCenter().addObserver(</span><br><span class="line">	<span class="keyword">self</span>, selector:<span class="string">"onBackground"</span>, name:<span class="string">"NSExtensionHostDidEnterBackgroundNotification"</span>, object: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"> <span class="type">NSNotificationCenter</span>.defaultCenter().addObserver(</span><br><span class="line">	<span class="keyword">self</span>, selector:<span class="string">"onForeground"</span>, name:<span class="string">"NSExtensionHostWillEnterForegroundNotification"</span>, object: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"> <span class="type">NSNotificationCenter</span>.defaultCenter().addObserver(</span><br><span class="line">	<span class="keyword">self</span>, selector:<span class="string">"onActive"</span>, name:<span class="string">"NSExtensionHostDidBecomeActiveNotification"</span>,object: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">&amp;nbsp;&amp;nbsp;上述代码中<span class="type">NSExtensionHostWillResignActiveNotification</span>对应的应用挂起事件处理方法onDeactivate里就是一个保存应用状态数据的不错选择，相对应的<span class="type">WillEnterForegroundNotification</span>的处理方法里可以读取回复应用状态数据。</span><br><span class="line"></span><br><span class="line"> *<span class="number">1.5</span>.<span class="number">2</span> 视图更新中的风险*</span><br><span class="line">&amp;nbsp;&amp;nbsp;虽然按照<span class="type">Apple</span>要求，我们可以只更新界面变化的内容，但值得注意的一点是，如果尝试更新时视图却处于不可见的状态，那么更新操作将会失被系统忽略而失败，你也无法得到操作失败的通知。典型的情况比如：视图控制器<span class="type">A</span>有一个文本标签，其内容是时刻变化的，然而控制器<span class="type">A</span>切换/弹出到了视图控制器<span class="type">B</span>，那么此时更新控制器<span class="type">A</span>的文本标签内容可能将会失败(<span class="type">A</span>已经处于<span class="type">Deactivated</span>状态)，关闭控制器<span class="type">B</span>返回控制器<span class="type">A</span>时其内容就并非最新的。有必要的话请通过设立好标识变量等方式辅助解决此问题。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> 资源优化</span><br><span class="line">--</span><br><span class="line">&amp;nbsp;&amp;nbsp;曾经在<span class="type">Xcode6</span>.2beta1测试版里我们是可以使用自定义字体的，然而不久后就被<span class="type">Apple</span>禁止了，而音频目前也不能直接在<span class="type">AppleWatch</span>上播放，因此这里我们主要讨论图像资源的优化。</span><br><span class="line"></span><br><span class="line">**<span class="number">2.1</span> 资源文件存储路径规划**</span><br><span class="line">&amp;nbsp;&amp;nbsp;在不考虑<span class="type">Framework</span>的情况下，通常<span class="type">WatchKit</span>应用的工程包括(iPhone)<span class="type">App</span>、<span class="type">WatchKit</span> <span class="type">Extension</span>、<span class="type">WatchKit</span> <span class="type">App</span>三个target，三个target默认使用其对应<span class="type">Bundle</span>中的资源文件。我们现在只关心后两个：</span><br><span class="line"> *<span class="number">2.1</span>.<span class="number">1</span> <span class="type">WatchKit</span> <span class="type">App</span> <span class="type">Bundle</span>*</span><br><span class="line">&amp;nbsp;&amp;nbsp;<span class="type">WatchKit</span> <span class="type">App</span> <span class="type">Bundle</span>里的图像资源可以直接用于<span class="type">Storyboard</span>里设置<span class="type">WKInterfaceImage</span>控件的image属性、<span class="type">WKInterfaceGroup</span>和<span class="type">WKInterfaceController</span>的background属性。  </span><br><span class="line">图像放这里还有个好处就是资源在应用安装的时候就拷贝到了<span class="type">AppleWatch</span>上，不需要再无线传输一遍。</span><br><span class="line">&amp;nbsp;&amp;nbsp;因此，我们在<span class="type">WatchKit</span> <span class="type">App</span> <span class="type">Bundle</span>里最好是存储应用<span class="type">UI</span>控件的背景底图等静态的资源，50MB的存储上限绝大多数情况都是够用的。然后，尽量使用<span class="type">Assets</span> <span class="type">Catalog</span>，可以避免真机运行时一些莫名其妙的找不到图像的问题。</span><br><span class="line"> *<span class="number">2.1</span>.<span class="number">2</span> <span class="type">WatchKit</span> <span class="type">Extension</span> <span class="type">Bundle</span>*</span><br><span class="line">&amp;nbsp;&amp;nbsp;<span class="type">WatchKit</span> <span class="type">Extension</span>是一种扩展，用于实现<span class="type">AppleWatch</span>应用的代码逻辑，但存储于此<span class="type">Bundle</span>的资源需要借助<span class="type">WKInterfaceImage</span>的setImage:/setImageData:或<span class="type">WKInterfaceGroupd</span>的setBackgroundImage:/setBackgroundImageData:/</span><br><span class="line">setBackgroundImageNamed:自动传输并显示到<span class="type">AppleWatch</span>上。这一过程若时间过长你会在手表界面右上角看到加载动画，造成的卡顿将影响使用体验。因此，我们在<span class="type">WatchKitExtension</span>里处理得最多的一般是动态生成、网络下载的图像。但实际情况中我们也常将一些静态图像存储于该<span class="type">Bundle</span>，一方面是能够方便的通过代码进行显示控制，另一方面对于某些显示次数不确定的图像（比如显示频次较低的游戏结束画面），在图片容量较小的情况下我们完全可以实时加载，或是开启后台线程实现预加载并将其放入缓存，这样也能够减少手表应用安装初始化的时间。</span><br><span class="line">&amp;nbsp;&amp;nbsp;这里有必要再补充讲一下缓存。我们知道<span class="type">AppleWatch</span>为每个应用设置了5MB的缓存空间，这对许多应用来说是足够的。但经过几个beta版的更新，<span class="type">Apple</span>已经去掉了<span class="type">FIFO</span>（先入先出）模式的自动支持，也就是说你必须手动管理这个缓存空间，添加图像到缓存时判断若添加失败则证明缓存已满，可删除不需要的缓存图像或者是放弃进行缓存。</span><br><span class="line">比如下面这段代码可以为<span class="type">WKInterfaceImage</span>设置检查是否有名为cacheName的缓存图，若有就直接取缓存，否则去<span class="type">Extension</span>的<span class="type">Bundle</span>取名为name的图像，并将其添加到缓存。</span><br><span class="line">```<span class="built_in">swift</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">WKInterfaceImage</span></span>&#123;  </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">setImageWithCacheNamed</span><span class="params">(name:String!,cacheName:String!)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> cImg: <span class="type">AnyObject</span>=<span class="type">WKInterfaceDevice</span>().cachedImages[cacheName]&#123;</span><br><span class="line">            <span class="keyword">self</span>.setImageNamed(cacheName)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> img=<span class="type">UIImage</span>(named: name)!</span><br><span class="line">            <span class="keyword">if</span> <span class="type">WKInterfaceDevice</span>().addCachedImage(img, name: cacheName)&#123;</span><br><span class="line">                <span class="keyword">self</span>.setImageNamed(cacheName)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.setImage(img)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;以上代码未实现FIFO，有兴趣的可以参考一下Github上的<a href="https://github.com/mkoehnke/WKImageCache" target="_blank" rel="external">WKImageCache</a>，或者直接用<br><a href="https://github.com/kiavashfaisali/KFSwiftImageLoader" target="_blank" rel="external">KFSwiftImageLoader</a>这个很完善的图像加载器。</p>
<p>&nbsp;&nbsp;再啰嗦一下WatchKit动画的图像处理，我们应该将所有动画帧放到一个UIImage里然后再传这个UIImage，而不是逐帧处理。有必要的话也记得将其添加至缓存空间。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">WKInterfaceImage</span></span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">setAnimationImageNamed</span><span class="params">(name:String!,range:NSRange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">let</span> imgs=<span class="type">NSMutableArray</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range.location..&lt;(range.location+range.length)&#123;</span><br><span class="line">            <span class="keyword">let</span> img=<span class="type">UIImage</span>(named: <span class="string">"<span class="subst">\(name)</span><span class="subst">\(i)</span>"</span>)!</span><br><span class="line">            imgs.addObject(img)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> animImage=<span class="type">UIImage</span>.animatedImageWithImages(imgs <span class="keyword">as</span> [<span class="type">AnyObject</span>], duration: <span class="number">1.0</span>)</span><br><span class="line">        <span class="keyword">self</span>.setImage(animImage)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2.2 缩减图像存储空间</strong><br>&nbsp;&nbsp;使用Mac平台的ImageOptim工具或<a href="www.tinypng.com/">TinyPNG服务</a>能够大幅压缩图像所占存储空间，这对于AppleWatch应用几乎是必须开展的一项工作。但值得注意的是我曾经碰到过压缩过的动画图像帧在模拟器上显示正常但在AppleWatch真机上出现alpha通道显示异常的问题。<br>&nbsp;&nbsp;来自Mike Swanson的一些相关经验值得分享给大家：<br>?为WKInterfaceDevice添加图像缓存时使用addCachedImageWithData:name: 能直接使用NSData数据无需转换，那么利用UIImageJPEGRepresentation()编码能够压缩图像减少传输开销。<br>? 为WKInterfaceDevice添加图像缓存时若使用addCachedImage:name:方法似乎使用的是PNG编码格式，但这个方法的实际空间占用是UIImagePNGRepresentation() 加额外的753字节，因此若使用addCachedImageWithData:name:可以为每个缓存图像节省753字节存储空间。<br>? cachedImages属性是一个键为名称、值为NSNumber型表示存储开销的字典，因此你也能够计算具体空间占用及可以资源。</p>
<p>&nbsp;&nbsp;最后，文章难免会产生的一些疏漏和不足之处，希望各位读者能够指出。谢谢！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>&nbsp;&nbsp;在笔者3月份为AppleWatch开发RebelSheep小游戏进行真机测试的时候就发现了目前AppleWatch上第三方应用的性能并不理想，而测试部分WatchAppStore里推荐的应用甚至都没能成功开启。尽管WatchOS 1.01已经提升了已]]>
    </summary>
    
      <category term="iOS" scheme="http:/tags/iOS/"/>
    
      <category term="swift" scheme="http:/tags/swift/"/>
    
      <category term="watchOS" scheme="http:/tags/watchOS/"/>
    
      <category term="blog" scheme="http:/categories/blog/"/>
    
  </entry>
  
</feed>